package parse;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Reader;

import st.ConstantRecord;
import st.Offset;
import st.ParamNode;
import st.ProcedureRecord;
import st.Record;
import st.SymbolTable;
import st.TableEntry;
import st.Total;
import st.Type;
import st.VarType;
import st.VariableRecord;

import analyzer.Lexical;
import analyzer.Token;
import analyzer.TokenType;

/**
 * 
 * @author Nisha Patel Date : 02/14/2013
 * 
 *         This class implements the Recursive Descent Parser. It evaluates the
 *         given grammar to parse the tokens generated by the Lexical Analyzer.
 * 
 */
public class RecDescParser {
	SymbolTable symbolTable = null;
	 int tempCount=1;
	 BufferedWriter out = null;
	
	/**
	 * This is the current token to be evaluated.
	 */
	private Token curToken;

	/**
	 * The reference for the Lexical Analayzer.
	 */
	private Lexical lexical = null;

	/**
	 * The constructor for the Parser.
	 * 
	 * @param reader
	 */
	public RecDescParser(Reader reader,BufferedWriter out) {
		lexical = new Lexical(reader);
	 symbolTable = new SymbolTable();
	 this.out = out;
	 
	 
	 
	}

	
	
	/**
	 * Returns the Next token from the Lexical Analyzer.
	 */
	public void getNextToken() {
		curToken = lexical.getNextToken();
	}

	/**
	 * Returns the Current Token.
	 * 
	 * @return The current token to be analyzed
	 */
	public Token getCurToken() {
		return curToken;
	}

	/**
	 * Matches the given token with the {@code curToken}
	 * 
	 * @param symbol
	 *            The token to be matched with the {@code curToken}
	 */
	private void match(Token symbol) {
		if (curToken.equals(symbol))
			curToken = lexical.getNextToken();
		else
			error("Error token mismatch");
	}

	/**
	 * Matches the given token type with the type of the {@code curToken}
	 * 
	 * @param tokenType
	 *            The token type to be matched with the type of the
	 *            {@code curToken}
	 */
	private void matchType(TokenType tokenType) {
		if (curToken.getType() == tokenType)
		{
			//	curToken = lexical.getNextToken();
		}
	
		else
			error("Error token Type mismatch");
	}

	/**
	 * Method to evaluate the rule for StatementPart Rule : StatementPart ->
	 * begint SeqOfStatements | empty
	 */
	public void statementPart(Offset offset) {
		Token beginToken = new Token(TokenType.RESWORD, "BEGIN");
		if (curToken.equals(beginToken)) {
			match(beginToken);
			seqOfStatements(offset);
		}
	}

	/**
	 * Method to evaluate the rule for Mode Rule : Mode -> vart | empty 
	 */
	public void mode() {

		Token varToken = new Token(TokenType.RESWORD, "VAR");
		if (curToken.equals(varToken)) {
			match(varToken);

		}
	}

	/**
	 * Method to evaluate the rule for MoreArgs Rule : MoreArgs -> ; ArgList | empty
	 */
	public void moreArgs(ProcedureRecord  record,Offset offset) {
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		if (curToken.equals(semicolonToken)) {
			match(semicolonToken);
			argList(record,offset);

		}
	}

	/**
	 * Method to evaluate the rule for ArgList Rule : ArgList -> Mode
	 * IdentifierList : TypeMark MoreArgs
	 */
	public void argList(ProcedureRecord  record,Offset offset) {
		mode();
		identifierList(record,offset);
		
		//Token colonToken = new Token(TokenType.SYMBOL, ":");
		//match(colonToken);
		//typeMark();
		moreArgs(record,offset);

	}

	/**
	 * Method to evaluate the rule for Args Rule : Args -> ( ArgList ) | empty
	 */
	public void args(ProcedureRecord record,Offset offset) {
		Token openParToken = new Token(TokenType.SYMBOL, "(");
		if (curToken.equals(openParToken)) {
			match(openParToken);
			argList(record,offset);
			Token closeParToken = new Token(TokenType.SYMBOL, ")");
			match(closeParToken);
		}

	}

	/**
	 * Method to evaluate the rule for ProcBody Rule : ProcBody ->
	 * DeclarativePart StatementPart endt
	 */
	public void procBody(Offset offset) {
		
		declarativePart(offset);
		statementPart(offset);
		Token endToken = new Token(TokenType.RESWORD, "END");
		match(endToken);
	}

	/**
	 * Method to evaluate the rule for ProcHeading Rule : ProcHeading -> proct
	 * idt Args
	 */
	public void procHeading(Offset offset) {
		String code = "";
		Token procToken = new Token(TokenType.RESWORD, "PROCEDURE");
		match(procToken);
		code = "proc ";
		code = code + curToken.getLexeme();
		
		matchType(TokenType.ID);
		
		symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
		
        symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth // make change to lookup. first look up then insert
		
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		ProcedureRecord procedureRecord = null;
		if(tableEntry != null){
			
	        procedureRecord  = new 	ProcedureRecord ();
			tableEntry.setRecord(procedureRecord);
		}
		symbolTable.setDepth(symbolTable.getDepth() + 1);
		curToken = lexical.getNextToken();
		
		emitto(code);
		args(procedureRecord,offset);
	}

	/**
	 * Method to evaluate the rule for ProcedureDecl Rule : ProcedureDecl ->
	 * ProcHeading ; ProcBody idt ;
	 */
	public void procedureDecl() {
		String code = "";
		Offset offset = new Offset();
		procHeading(offset);
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		match(semicolonToken);
		Offset offset2 = new Offset();
		procBody(offset2);
		matchType(TokenType.ID);
		code = "endp ";
		code = code + curToken.getLexeme();
		curToken = lexical.getNextToken();
		match(semicolonToken);
		emitto(code);
		emitto("");
		//symbolTable.writeTable(symbolTable.getDepth());
		symbolTable.deleteDepth(symbolTable.getDepth());
		symbolTable.setDepth(symbolTable.getDepth() - 1);
		
	}

	/**
	 * Method to evaluate the rule for ProcPart Rule : ProcPart -> ProcedureDecl
	 * ProcPart | empty
	 */
	public void procPart() { // This call methode call self We need to make
								// change to LL1
		Token procToken = new Token(TokenType.RESWORD, "PROCEDURE");
		if (curToken.equals(procToken)) {
			procedureDecl();
			procPart();
		}
	}

	/**
	 * Method to evaluate the rule for Value Rule : Value -> NumericalLiteral
	 */
	public void value() {
		matchType(TokenType.NUMBER);
		//curToken = lexical.getNextToken();
		
		}

	/**
	 * Method to evaluate the rule for TypeMark Rule : TypeMark -> integert |
	 * realt | chart
	 */
	public void typeMark(Type type) {
		Token integerToken = new Token(TokenType.RESWORD, "INTEGER");
		Token realToken = new Token(TokenType.RESWORD, "REAL");
		Token charToken = new Token(TokenType.RESWORD, "CHAR");
		if (curToken.equals(integerToken)) {
			match(integerToken);
			type.setVarType(VarType.intType);
		}

		else if (curToken.equals(realToken)) {
			match(realToken);
			type.setVarType(VarType.realType);
		} else if (curToken.equals(charToken)) {
			match(charToken);
			type.setVarType(VarType.charType);
		}

		else
			error("Error: No match found for integert | realt | chart in typemark ");
	}

	/**
	 * Method to evaluate the rule for IdentifierList Rule : IdentifierList ->
	 * idt identifierList1
	 */
	public void identifierList(ProcedureRecord  record,Offset offset) { // convert this gramarer to LL1 grammare

		VariableRecord variableRecord = null;
		ParamNode param = null;
		matchType(TokenType.ID);
		symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
		symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth // make change to lookup. first look up then insert
		
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		
		if(tableEntry != null){
			variableRecord = new VariableRecord ();
		//	variableRecord.setOffset(offset);
			tableEntry.setRecord(variableRecord);
			
			//set size,offset,type
			
			if(record != null){
				variableRecord.setProcVar(true);
				record.setNoOfParameters(record.getNoOfParameters() +1);
				//record.setSizeOfLocalVariables(record.getSizeOfLocalVariables() + variableRecord.getSize());
				 param = new ParamNode();
				//param.setParameterType(variableRecord.getVarType());
				ParamNode node = null;
				node = record.getParameterList();
				if(node == null)
				{
					record.setParameterList(param);
				}
				else
				{
				    while(node.getNext() != null) {
				    	node = node.getNext();
				    }
					node.setNext(param);
				}
			}
		}
		curToken = lexical.getNextToken();
		
		Type type = new Type();
		int count = 0;
		Total total = new Total();
		total.setNo(1);
		identifierList1(record,offset,type,count,total);
		
	    if(variableRecord != null) {
		setSizeOffsetType(record,variableRecord,type,param);
		variableRecord.setOffset(offset.getOffset() + count*type.getOffset());
		if(param != null) {
			param.setOffset(variableRecord.getOffset());
		    }
		offset.setOffset(offset.getOffset() + total.getNo()*type.getOffset() );
		    }
		
	}

	private void setSizeOffsetType(ProcedureRecord record,VariableRecord variableRecord,Type type,ParamNode param ){
		VarType varType = type.getVarType();
		variableRecord.setVarType(varType);
		
		if(varType == VarType.charType) {
			variableRecord.setSize(1);
			type.setOffset(1);
			
		}
		else if (varType == VarType.intType) {
			variableRecord.setSize(2);
			type.setOffset(2);
		}
		else if(varType == VarType.realType) {
			variableRecord.setSize(4);
			type.setOffset(4);
		}
		
		if(param != null) {
			param.setParameterType(variableRecord.getVarType());
			param.setSize(variableRecord.getSize());
			
		}
		if(record != null)
			record.setSizeOfLocalVariables(record.getSizeOfLocalVariables() + variableRecord.getSize());
	}
	/**
	 * Method to evaluate the rule for IdentifierList1 Rule : IdentifierList1 ->
	 * , idt identifierList1 | empty
	 */
	public void identifierList1(ProcedureRecord record,Offset offset,Type type,int count,Total total) {
		Token commaToken = new Token(TokenType.SYMBOL, ",");
		VariableRecord variableRecord = null;
		ParamNode param = null;
		if (curToken.equals(commaToken)) {
			match(commaToken);
			matchType(TokenType.ID);
			symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
			symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth
			
			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			if(tableEntry != null){
				variableRecord = new VariableRecord ();
			//	variableRecord.setOffset(offset);
				tableEntry.setRecord(variableRecord);

				//set vartype,size,offset
			
				if(record != null){
					variableRecord.setProcVar(true);
					record.setNoOfParameters(record.getNoOfParameters() +1);
					//record.setSizeOfLocalVariables(record.getSizeOfLocalVariables() + variableRecord.getSize());
					 param = new ParamNode();
					//param.setParameterType(variableRecord.getVarType());
					ParamNode node = null;
					node = record.getParameterList();
					if(node == null)
					{
						record.setParameterList(param);
					}
					else
					{
					    while(node.getNext() != null) {
					    	node = node.getNext();
					    }
						node.setNext(param);
					}
				}
				
			}
			curToken = lexical.getNextToken();
			
			count++;
			total.setNo(total.getNo() + 1);
			identifierList1(record,offset,type,count,total);
			
		}
		
		else {
		Token colonToken = new Token(TokenType.SYMBOL, ":");
		match(colonToken);
	
		typeMark(type);
		}
		
		if(variableRecord != null ){
		setSizeOffsetType(record,variableRecord,type, param);
		variableRecord.setOffset(offset.getOffset() + count*type.getOffset());
		if(param != null) {
			param.setOffset(variableRecord.getOffset());
		    }
	//	offset.setOffset(offset.getOffset() + count*type.getOffset() );
		}
	}

	/**
	 * Method to evaluate the rule for VarTail Rule : VarTail -> IdentifierList
	 * : TypeMark ; VarTail | empty
	 */
	public void varTail(Offset offset) {

		if (curToken.getType() == TokenType.ID) {

			identifierList(null,offset);
			
			/*
			Token colonToken = new Token(TokenType.SYMBOL, ":");
			match(colonToken);
			Type type = new Type();
			typeMark(type);
			*/
			Token semicolonToken = new Token(TokenType.SYMBOL, ";");
			match(semicolonToken);
			varTail(offset);
		}
	}

	/**
	 * Method to evaluate the rule for VarPart Rule : VarPart -> vart VarTail |
	 * empty
	 */
	public void varPart(Offset offset) {

		Token varToken = new Token(TokenType.RESWORD, "VAR");
		if (curToken.equals(varToken)) {
			match(varToken);
			varTail(offset);
		}
	}

	/**
	 * Method to evaluate the rule for ConstTail Rule : ConstTail -> idt = Value
	 * ; ConstTail | empty
	 */
	public void constTail(Offset offset) {

		if (curToken.getType() == TokenType.ID) {
			matchType(TokenType.ID);
			symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
			symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth
			
			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			
			curToken = lexical.getNextToken();
			Token equalToken = new Token(TokenType.RELOP, "=");
			match(equalToken);
			
			value();
			
			if(tableEntry != null){
				ConstantRecord  constantRecord;
				constantRecord = new ConstantRecord();
				tableEntry.setRecord(constantRecord);
				if(curToken.getValue().contains(".")) {
					constantRecord.setfValue(Float.parseFloat(curToken.getValue()));
					constantRecord.setVarType(VarType.realType);
					constantRecord.setOffset(offset.getOffset());
					offset.setOffset(offset.getOffset() + 4);
					//set the offset
				}
				else {
					constantRecord.setiValue(Integer.parseInt(curToken.getValue()));
					constantRecord.setVarType(VarType.intType);
					constantRecord.setOffset(offset.getOffset());
					offset.setOffset(offset.getOffset() + 2);
					//set the offset
				}
				
			}
			curToken = lexical.getNextToken();
			
			Token semicolonToken = new Token(TokenType.SYMBOL, ";");
			match(semicolonToken);
			constTail(offset);
		}

	}

	/**
	 * Method to evaluate the rule for ConstPart Rule : ConstPart -> constt
	 * ConstTail | empty
	 */
	public void constPart(Offset offset) {
		Token constToken = new Token(TokenType.RESWORD, "CONST");
		if (curToken.equals(constToken)) {
			match(constToken);
			
			constTail(offset);
		}

	}

	/**
	 * Method to evaluate the rule for DeclarativePart Rule : DeclarativePart ->
	 * ConstPart VarPart ProcPart
	 */
	public void declarativePart(Offset offset) {
		constPart(offset);
		
		varPart(offset);
		procPart();

	}

	//
	/**
	 * Method to evaluate the rule for Prog Rule : Prog -> modulet idt;
	 * DeclarativePart StatementPart endt idt.
	 */
	public void prog() {
		String code = "";
		String moduleName = "";
		Token moduleToken = new Token(TokenType.RESWORD, "MODULE");

		match(moduleToken);
		matchType(TokenType.ID);
		moduleName = curToken.getLexeme();
       // System.out.println("the current token" +curToken.getLexeme());
		symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
		symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth());
		
		curToken = lexical.getNextToken();
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		match(semicolonToken);
		symbolTable.setDepth(symbolTable.getDepth() + 1);
		//int offset = 0;
		Offset offset = new Offset();
		declarativePart(offset);
		emitto("proc "+ moduleName);
		statementPart(offset);
		//symbolTable.writeTable(symbolTable.getDepth());
		symbolTable.deleteDepth(symbolTable.getDepth());
		Token endToken = new Token(TokenType.RESWORD, "END");
		match(endToken);
		symbolTable.setDepth(symbolTable.getDepth() - 1);
		//symbolTable.	(symbolTable.getDepth());
		symbolTable.deleteDepth(symbolTable.getDepth());
		matchType(TokenType.ID);
		code = "endp "+ curToken.getLexeme();
		curToken = lexical.getNextToken();
		Token periodToken = new Token(TokenType.SYMBOL, ".");
		match(periodToken);
		emitto(code);
		emitto("");
		emitto("START "+ moduleName);
	}

	/**
	 * 
	 * @param message
	 */
	public void error(String message) {
		throw new RuntimeException(message + " - " + curToken);
	}
	/**
	 * Method to evaluate the rule for seqOfStatements Rule : seqOfStatements -> Statement  ; StatTail |empty
	 */
	
	public void seqOfStatements(Offset offset)
	{
		if (curToken.getType() == TokenType.ID) 
		{
			Statement(offset);
			Token semicolon = new Token(TokenType.SYMBOL, ";");
			match(semicolon);
			StatTail(offset);
		}	
	}
	
	/**
	 * Method to evaluate the rule for StatTail Rule : StatTail -> Statement  ; StatTail |Empty
	 */
public void StatTail(Offset offset)
	{
	if (curToken.getType() == TokenType.ID) 
	{
		Statement(offset);
		Token semicolon = new Token(TokenType.SYMBOL, ";");
		match(semicolon);
		StatTail(offset);
	}
	
	}
/**
 * Method to evaluate the rule for Statement Rule : Statement -> AssignStat	|IOStat
 */
public void Statement(Offset offset)
{
	if (curToken.getType() == TokenType.ID) 
	{
		AssignStat(offset);	
	}
	else 
		IOStat();
}

// ParamsTail		->	, idt ParamsTail | , num ParamsTail | empty

public void paramsTail() {
	String code = "";

	Token commaToken = new Token(TokenType.SYMBOL, ",");
	
	if (curToken.equals(commaToken)) {
		
		match(commaToken);
		if (curToken.getType() == TokenType.ID) {

			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
				error("Undeclared variable at line :"+curToken.getLinenum());
			}
			code = "push " + curToken.getLexeme() + " ";

			matchType(TokenType.ID);	
			curToken = lexical.getNextToken();
			
		   paramsTail();	
		   emit(code);
		}
		else {
			code = "push " + curToken.getLexeme() + " ";
			matchType(TokenType.NUMBER);
			curToken = lexical.getNextToken();
			
			paramsTail();
			 emit(code);
		}
		
	}
	
	
	
	
}

//Params			->	idt ParamsTail | num ParamsTail| empty

public void params() {
	String code = "";
	if (curToken.getType() == TokenType.ID) {
		
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
			error("Undeclared variable at line :"+curToken.getLinenum());
		}
		
		code = "push " +  curToken.getLexeme() + " ";
			
		matchType(TokenType.ID);	
		curToken = lexical.getNextToken();
		paramsTail();
		emit(code);
		
	}
	else if(curToken.getType() == TokenType.NUMBER) 
	{
		code = "push " + curToken.getLexeme() + " ";
	    matchType(TokenType.NUMBER);
	    curToken = lexical.getNextToken();
	    
	paramsTail();
	emit(code);
	}
}

/**
 * ProcCall	->	idt ( Params )
 */
public void procCall() {
	
	TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
	if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
		error("Undeclared variable at line :"+curToken.getLinenum());
	 }

	String code = "";
	code="call ";
	code=code + curToken.getLexeme();
	matchType(TokenType.ID);
	curToken = lexical.getNextToken();
	
	Token openParToken = new Token(TokenType.SYMBOL, "(");
	
		match(openParToken);
		params();
		Token closeParToken = new Token(TokenType.SYMBOL, ")");
		match(closeParToken);
	emit(code);

}
   
/**
 * Method to evaluate the rule for AssignStat Rule : AssignStat -> idt  :=  Expr | ProcCall
 */

	public void AssignStat(Offset offset)
	{
		String code = null;
		EntryObj expPlace  = new  EntryObj();
		
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
			error("Undeclared variable at line :"+curToken.getLinenum());
		 }
		if (tableEntry.getRecord() instanceof VariableRecord)
		{
			//	curToken = lexical.getNextToken();
		
	   // code = curToken.getLexeme();
	    String bpLex =getLexemeValue(tableEntry);
	    code =  bpLex;
		matchType(TokenType.ID);
		curToken = lexical.getNextToken();
		Token assigment = new Token(TokenType.ASSIGNOP, ":=");
			match(assigment);
			Expr(expPlace,offset);
			code = code + "   =   ";
			String expLex =getLexemeValue(expPlace.getEntry());
			if(expPlace.isSign()) expLex = '-'+expLex; 
			code = code + expLex ; //expPlace.getEntry().getLexeme();
			emit(code);
		}
		else {
			procCall();
		}
	}
	/**
	 * Method to evaluate the rule for IOStat Rule : IOStat -> empty
	 */
	public void IOStat()
	{
		
	}
	/**
	 * Method to evaluate the rule for Expr Rule : Expr -> Relation
	 */
	public void  Expr(EntryObj expPlace,Offset offset){
		
		Relation(expPlace,offset);
	}
	/**
	 * Method to evaluate the rule for Relation Rule : Relation -> SimpleExpr
	 */
	public void Relation(EntryObj expPlace,Offset offset)
	{
		SimpleExpr(expPlace,offset);
	}
	/**
	 * Method to evaluate the rule for SimpleExpr Rule : SimpleExpr -> Term MoreTerm
	 */
	public void SimpleExpr(EntryObj expPlace,Offset offset)
	{
		EntryObj termPlace  = new  EntryObj();
		Term(termPlace,offset);
		MoreTerm(termPlace,offset);	
		expPlace.setEntry(termPlace.getEntry());
		expPlace.setSign(termPlace.isSign());
	}
	
	/**
	 * Method to evaluate the rule for MoreTerm Rule : MoreTerm -> Addop Term MoreTerm| empty
	 */
	public void MoreTerm(EntryObj moretPlace,Offset offset)
	{
		String code = null;
		EntryObj termPlace  = new  EntryObj();
		//EntryObj tempPlace  = new  EntryObj();
		Token addOp = new Token(TokenType.ADDOP, "+");
		Token subOp = new Token(TokenType.ADDOP, "-");
		Token orOp = new Token(TokenType.ADDOP, "OR");
		if ( curToken.equals(addOp) ||curToken.equals(subOp) ||curToken.equals(orOp))
		{
		
		String curlex = curToken.getLexeme();
			addOp();
			Term(termPlace,offset);
			String tplc = getLexemeValue(termPlace.getEntry());
			if(termPlace.isSign()) tplc = '-'+tplc;
			TableEntry temp	= newTemp(offset);
			//temp.setRecord(record)
			String tmpLex = getLexemeValue(temp);
			code = tmpLex; //temp.getLexeme();
			code = code + "   =   ";
			String mplc = getLexemeValue(moretPlace.getEntry());
			if(moretPlace.isSign()) mplc = '-'+mplc;
			
			
			code = code + mplc + " ";
			code = code + curlex + " ";
				
			code = code + tplc;
			moretPlace.setEntry(temp);
			emit(code);
			MoreTerm(moretPlace,offset);
		}
	}

/**
 * public void MoreTerm(EntryObj moretPlace,Offset offset)
	{
		String code = null;
		EntryObj termPlace  = new  EntryObj();
		//EntryObj tempPlace  = new  EntryObj();
		Token addOp = new Token(TokenType.ADDOP, "+");
		Token subOp = new Token(TokenType.ADDOP, "-");
		Token orOp = new Token(TokenType.ADDOP, "OR");
		if ( curToken.equals(addOp) ||curToken.equals(subOp) ||curToken.equals(orOp))
		{
		TableEntry temp	= newTemp(offset);
		//temp.setRecord(record)
		String tmpLex = getLexemeValue(temp);
		code = tmpLex; //temp.getLexeme();
		code = code + "   =   ";
		String mplc = getLexemeValue(moretPlace.getEntry());
		code = code + mplc + " ";
		code = code + curToken.getLexeme() + " ";
		
			addOp();
			Term(termPlace,offset);
			String tplc = getLexemeValue(termPlace.getEntry());
			
			code = code + tplc;
			moretPlace.setEntry(temp);
			emit(code);
			MoreTerm(moretPlace,offset);
		}
	}
	
 */
	/**
	 * Method to evaluate the rule for Term Rule : Term -> Factor  MoreFactor
	 */
	public void Term(EntryObj termPlace,Offset offset)
	{
		boolean sign = false;
		factor(termPlace,offset,sign);
		MoreFactor(termPlace,offset,sign);
	}
	/**
	 * Method to evaluate the rule for MoreFactor Rule : MoreFactor -> Mulop Factor MoreFactor| empty
	 */
	public void MoreFactor(EntryObj rPlace,Offset offset,boolean sign){
		String code = null;
		Token diviop = new Token(TokenType.MULOP, "/");
		Token divop = new Token(TokenType.MULOP, "DIV");
		Token modop = new Token(TokenType.MULOP, "MOD");
		Token assigop = new Token(TokenType.MULOP, "AND");
		Token mulop = new Token(TokenType.MULOP, "*");
		EntryObj termPlace  = new  EntryObj();
		if ( curToken.equals(mulop) ||curToken.equals(diviop) ||curToken.equals(divop) ||curToken.equals(modop) ||curToken.equals(assigop)) {
			String curlex = curToken.getLexeme();
			Mulop();
			factor(termPlace,offset,sign);
			String tplc = getLexemeValue(termPlace.getEntry()) + " ";
			if(termPlace.isSign()) tplc = '-'+tplc;
			TableEntry temp	= newTemp(offset);
			String tmpLex = getLexemeValue(temp);
			code = tmpLex ; //temp.getLexeme();
			code = code + "   =   ";
			String rplc = getLexemeValue(rPlace.getEntry()) + " ";
			if(rPlace.isSign()) rplc = '-'+rplc;
			code = code + rplc + " ";
			code = code + curlex + " ";
			code = code + tplc;
				
			rPlace.setEntry(temp);
			emit(code);
			MoreFactor(rPlace,offset,sign);
			
		}
	}
	
	/*
	 * public void MoreFactor(EntryObj rPlace,Offset offset){
		String code = null;
		Token diviop = new Token(TokenType.MULOP, "/");
		Token divop = new Token(TokenType.MULOP, "DIV");
		Token modop = new Token(TokenType.MULOP, "MOD");
		Token assigop = new Token(TokenType.MULOP, "AND");
		Token mulop = new Token(TokenType.MULOP, "*");
		EntryObj termPlace  = new  EntryObj();
		if ( curToken.equals(mulop) ||curToken.equals(diviop) ||curToken.equals(divop) ||curToken.equals(modop) ||curToken.equals(assigop)) {
			TableEntry temp	= newTemp(offset);
			String tmpLex = getLexemeValue(temp);
			code = tmpLex ; //temp.getLexeme();
			code = code + "   =   ";
			String rplc = getLexemeValue(rPlace.getEntry()) + " ";
			code = code + rplc;
			code = code + curToken.getLexeme() + " ";
			Mulop();
			factor(termPlace,offset);
			String tplc = getLexemeValue(termPlace.getEntry()) + " ";
			code = code + tplc;
			rPlace.setEntry(temp);
			emit(code);
			MoreFactor(rPlace,offset);
			
		}
	}
	 * 
	 * 
	 */
	
	/**
	 * Method to evaluate the rule for factor Rule : factor -> idt |numt| ( Expr )|~ Factor|SignOp Factor
	 * empty
	 */
public void factor(EntryObj tPlace,Offset offset,boolean sign){
		Token openParToken = new Token(TokenType.SYMBOL, "(");
		Token negation = new Token(TokenType.SYMBOL, "~");
		Token closeParToken = new Token(TokenType.SYMBOL, ")");
	
		String code = null;
		if (curToken.getType() == TokenType.ID) {
			
			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
				error("Undeclared variable at line :"+curToken.getLinenum());
			}
			tPlace.setEntry(tableEntry);
			tPlace.setSign(sign);
			matchType(TokenType.ID);	
			curToken = lexical.getNextToken();
		}
		else if(curToken.getType() == TokenType.NUMBER) 
		{
			TableEntry temp = newTemp(offset);
			tPlace.setEntry(temp);
			String tmpLex = getLexemeValue(temp);
			code = tmpLex; //temp.getLexeme();
			code = code + "   =   ";
			if(sign) code = code + '-' + curToken.getLexeme();
			else code = code + curToken.getLexeme();
		matchType(TokenType.NUMBER);
		emit(code);
		curToken = lexical.getNextToken();
		}
		else if(curToken.equals(openParToken))
		{
			match(openParToken);
			Expr(tPlace,offset);
			match(closeParToken);
		}
		else if(curToken.equals(negation))
		{
			match(negation);
			factor(tPlace,offset,true);
		}
		else
		{
			SignOp();
			factor(tPlace,offset,true);
		}
			
	}
	
	
/**
 * Method to evaluate the rule for addOp Rule : addOp ->Addop		+ | - | OR
 */
	public void addOp()
	{
		Token addOp = new Token(TokenType.ADDOP, "+");
		Token subOp = new Token(TokenType.ADDOP, "-");
		Token orOp = new Token(TokenType.ADDOP, "OR");
		if (curToken.equals(addOp)) {
			match(addOp);
			}
		else if (curToken.equals(subOp)) {
			match(subOp);
			}
		else  {
			match(orOp);
			}
	}
	
	/**
	 * Method to evaluate the rule for Mulop Rule : Mulop ->  *| /  |DIV|MOD| AND
	 */
	public void Mulop(){
		Token diviop = new Token(TokenType.MULOP, "/");
		Token divop = new Token(TokenType.MULOP, "DIV");
		Token modop = new Token(TokenType.MULOP, "MOD");
		Token assigop = new Token(TokenType.MULOP, "AND");
		Token mulop = new Token(TokenType.MULOP, "*");
		if (curToken.equals(mulop)) {
		match(mulop);
		}
		else if (curToken.equals(diviop)) 
			{
			match(diviop);
		}
		else if (curToken.equals(divop)) 
		{
		match(divop);
	}
		else if (curToken.equals(modop)) 
		{
		match(modop);
	}
		else
		match(assigop);
	
			
	}
	/**
	 * Method to evaluate the rule for SignOp Rule : SignOp -> -
	 */
	public void SignOp(){
		
		Token signop = new Token(TokenType.ADDOP, "-");
		match(signop);
		
	}
	
	/**
	 * Method to create the new temporary variable.
	 */ 
public TableEntry newTemp(Offset offset)
{
	String temp = "_T" + tempCount;
	symbolTable.insert(temp, TokenType.ID,symbolTable.getDepth());
	tempCount++;
	TableEntry tableEntry = symbolTable.lookup(temp);
	VariableRecord variableRecord = new VariableRecord ();
	variableRecord.setOffset(offset.getOffset());
	offset.setOffset(offset.getOffset() + 2);
	tableEntry.setRecord(variableRecord);

    return tableEntry;
}
	
public void emit (String code)
{
	
	System.out.println("\t"+code);
	try {
		out.write("\t"+code+"\n");
	} catch (IOException e) {
		e.printStackTrace();
	}
}

public void emitto (String code)
{
	System.out.println(code);
	try {
		out.write(code+"\n");
	} catch (IOException e) {
		e.printStackTrace();
	}
}

public String getLexemeValue(TableEntry tableEntry)
{
	String value = "";
	int ofs = 0;
	if(tableEntry != null)
	{
		if(tableEntry.getDepth() == 1)
		{
			value = tableEntry.getLexeme();
		}
		
		else
		{
			
			value = "_bp" ;
			Record record = tableEntry.getRecord();
			if (record != null) {
			if(record instanceof VariableRecord) {
				VariableRecord varRecord = (VariableRecord)record;
				if(varRecord.isProcVar()) {
					ofs = ofs + 4;
					value = value + '+';
				 }
				else {
					ofs = ofs + 2;	
					value = value + '-';
				}
				ofs = ofs + varRecord.getOffset();
			}
			else if (record instanceof ConstantRecord){
				ConstantRecord consRecord = (ConstantRecord)record;
				ofs = ofs + 2;
				ofs = ofs + consRecord.getOffset();
				value = value + '-';
			
			}
			value = value + ofs;
			}
			else {
				value = tableEntry.getLexeme();
			}
		}
	}
	else
	{
		value = "0";
		
	}
	return value;
}
}

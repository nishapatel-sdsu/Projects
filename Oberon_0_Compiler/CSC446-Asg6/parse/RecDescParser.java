package parse;

import java.io.Reader;

import st.ConstantRecord;
import st.Offset;
import st.ParamNode;
import st.ProcedureRecord;
import st.SymbolTable;
import st.TableEntry;
import st.Total;
import st.Type;
import st.VarType;
import st.VariableRecord;

import analyzer.Lexical;
import analyzer.Token;
import analyzer.TokenType;

/**
 * 
 * @author Nisha Patel Date : 02/14/2013
 * 
 *         This class implements the Recursive Descent Parser. It evaluates the
 *         given grammar to parse the tokens generated by the Lexical Analyzer.
 * 
 */
public class RecDescParser {
	SymbolTable symbolTable = null;
	
	/**
	 * This is the current token to be evaluated.
	 */
	private Token curToken;

	/**
	 * The reference for the Lexical Analayzer.
	 */
	private Lexical lexical = null;

	/**
	 * The constructor for the Parser.
	 * 
	 * @param reader
	 */
	public RecDescParser(Reader reader) {
		lexical = new Lexical(reader);
	 symbolTable = new SymbolTable();
	}

	/**
	 * Returns the Next token from the Lexical Analyzer.
	 */
	public void getNextToken() {
		curToken = lexical.getNextToken();
	}

	/**
	 * Returns the Current Token.
	 * 
	 * @return The current token to be analyzed
	 */
	public Token getCurToken() {
		return curToken;
	}

	/**
	 * Matches the given token with the {@code curToken}
	 * 
	 * @param symbol
	 *            The token to be matched with the {@code curToken}
	 */
	private void match(Token symbol) {
		if (curToken.equals(symbol))
			curToken = lexical.getNextToken();
		else
			error("Error token mismatch");
	}

	/**
	 * Matches the given token type with the type of the {@code curToken}
	 * 
	 * @param tokenType
	 *            The token type to be matched with the type of the
	 *            {@code curToken}
	 */
	private void matchType(TokenType tokenType) {
		if (curToken.getType() == tokenType)
		{
			//	curToken = lexical.getNextToken();
		}
	
		else
			error("Error token Type mismatch");
	}

	/**
	 * Method to evaluate the rule for StatementPart Rule : StatementPart ->
	 * begint SeqOfStatements | empty
	 */
	public void statementPart() {
		Token beginToken = new Token(TokenType.RESWORD, "BEGIN");
		if (curToken.equals(beginToken)) {
			match(beginToken);
			seqOfStatements();
		}
	}

	/**
	 * Method to evaluate the rule for Mode Rule : Mode -> vart | empty 
	 */
	public void mode() {

		Token varToken = new Token(TokenType.RESWORD, "VAR");
		if (curToken.equals(varToken)) {
			match(varToken);

		}
	}

	/**
	 * Method to evaluate the rule for MoreArgs Rule : MoreArgs -> ; ArgList | empty
	 */
	public void moreArgs(ProcedureRecord  record,Offset offset) {
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		if (curToken.equals(semicolonToken)) {
			match(semicolonToken);
			argList(record,offset);

		}
	}

	/**
	 * Method to evaluate the rule for ArgList Rule : ArgList -> Mode
	 * IdentifierList : TypeMark MoreArgs
	 */
	public void argList(ProcedureRecord  record,Offset offset) {
		mode();
		identifierList(record,offset);
		
		//Token colonToken = new Token(TokenType.SYMBOL, ":");
		//match(colonToken);
		//typeMark();
		moreArgs(record,offset);

	}

	/**
	 * Method to evaluate the rule for Args Rule : Args -> ( ArgList ) | empty
	 */
	public void args(ProcedureRecord record,Offset offset) {
		Token openParToken = new Token(TokenType.SYMBOL, "(");
		if (curToken.equals(openParToken)) {
			match(openParToken);
			argList(record,offset);
			Token closeParToken = new Token(TokenType.SYMBOL, ")");
			match(closeParToken);
		}

	}

	/**
	 * Method to evaluate the rule for ProcBody Rule : ProcBody ->
	 * DeclarativePart StatementPart endt
	 */
	public void procBody(Offset offset) {
		declarativePart(offset);
		statementPart();
		Token endToken = new Token(TokenType.RESWORD, "END");
		match(endToken);
	}

	/**
	 * Method to evaluate the rule for ProcHeading Rule : ProcHeading -> proct
	 * idt Args
	 */
	public void procHeading(Offset offset) {
		Token procToken = new Token(TokenType.RESWORD, "PROCEDURE");
		match(procToken);
		matchType(TokenType.ID);
		
		symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
		
   symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth // make change to lookup. first look up then insert
		
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		ProcedureRecord procedureRecord = null;
		if(tableEntry != null){
			
	        procedureRecord  = new 	ProcedureRecord ();
			tableEntry.setRecord(procedureRecord);
		}
		symbolTable.setDepth(symbolTable.getDepth() + 1);
		curToken = lexical.getNextToken();
		
		
		args(procedureRecord,offset);
	}

	/**
	 * Method to evaluate the rule for ProcedureDecl Rule : ProcedureDecl ->
	 * ProcHeading ; ProcBody idt ;
	 */
	public void procedureDecl() {
		Offset offset = new Offset();
		procHeading(offset);
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		match(semicolonToken);
		procBody(offset);
		matchType(TokenType.ID);
		curToken = lexical.getNextToken();
		match(semicolonToken);
		symbolTable.writeTable(symbolTable.getDepth());
		symbolTable.deleteDepth(symbolTable.getDepth());
		symbolTable.setDepth(symbolTable.getDepth() - 1);
		
	}

	/**
	 * Method to evaluate the rule for ProcPart Rule : ProcPart -> ProcedureDecl
	 * ProcPart | empty
	 */
	public void procPart() { // This call methode call self We need to make
								// change to LL1
		Token procToken = new Token(TokenType.RESWORD, "PROCEDURE");
		if (curToken.equals(procToken)) {
			procedureDecl();
			procPart();
		}
	}

	/**
	 * Method to evaluate the rule for Value Rule : Value -> NumericalLiteral
	 */
	public void value() {
		matchType(TokenType.NUMBER);
		//curToken = lexical.getNextToken();
		
		}

	/**
	 * Method to evaluate the rule for TypeMark Rule : TypeMark -> integert |
	 * realt | chart
	 */
	public void typeMark(Type type) {
		Token integerToken = new Token(TokenType.RESWORD, "INTEGER");
		Token realToken = new Token(TokenType.RESWORD, "REAL");
		Token charToken = new Token(TokenType.RESWORD, "CHAR");
		if (curToken.equals(integerToken)) {
			match(integerToken);
			type.setVarType(VarType.intType);
		}

		else if (curToken.equals(realToken)) {
			match(realToken);
			type.setVarType(VarType.realType);
		} else if (curToken.equals(charToken)) {
			match(charToken);
			type.setVarType(VarType.charType);
		}

		else
			error("Error: No match found for integert | realt | chart in typemark ");
	}

	/**
	 * Method to evaluate the rule for IdentifierList Rule : IdentifierList ->
	 * idt identifierList1
	 */
	public void identifierList(ProcedureRecord  record,Offset offset) { // convert this gramarer to LL1 grammare

		VariableRecord variableRecord = null;
		ParamNode param = null;
		matchType(TokenType.ID);
		symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
		symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth // make change to lookup. first look up then insert
		
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		
		if(tableEntry != null){
			variableRecord = new VariableRecord ();
		//	variableRecord.setOffset(offset);
			tableEntry.setRecord(variableRecord);
			
			//set size,offset,type
			
			if(record != null){
				record.setNoOfParameters(record.getNoOfParameters() +1);
				//record.setSizeOfLocalVariables(record.getSizeOfLocalVariables() + variableRecord.getSize());
				 param = new ParamNode();
				//param.setParameterType(variableRecord.getVarType());
				ParamNode node = null;
				node = record.getParameterList();
				if(node == null)
				{
					record.setParameterList(param);
				}
				else
				{
				    while(node.getNext() != null) {
				    	node = node.getNext();
				    }
					node.setNext(param);
				}
			}
		}
		curToken = lexical.getNextToken();
		
		Type type = new Type();
		int count = 0;
		Total total = new Total();
		total.setNo(1);
		identifierList1(record,offset,type,count,total);
		
	    if(variableRecord != null) {
		setSizeOffsetType(record,variableRecord,type,param);
		variableRecord.setOffset(offset.getOffset() + count*type.getOffset());
		if(param != null) {
			param.setOffset(variableRecord.getOffset());
		    }
		offset.setOffset(offset.getOffset() + total.getNo()*type.getOffset() );
		    }
		
	}

	private void setSizeOffsetType(ProcedureRecord record,VariableRecord variableRecord,Type type,ParamNode param ){
		VarType varType = type.getVarType();
		variableRecord.setVarType(varType);
		
		if(varType == VarType.charType) {
			variableRecord.setSize(1);
			type.setOffset(1);
			
		}
		else if (varType == VarType.intType) {
			variableRecord.setSize(2);
			type.setOffset(2);
		}
		else if(varType == VarType.realType) {
			variableRecord.setSize(4);
			type.setOffset(4);
		}
		
		if(param != null) {
			param.setParameterType(variableRecord.getVarType());
			param.setSize(variableRecord.getSize());
			
		}
		if(record != null)
			record.setSizeOfLocalVariables(record.getSizeOfLocalVariables() + variableRecord.getSize());
	}
	/**
	 * Method to evaluate the rule for IdentifierList1 Rule : IdentifierList1 ->
	 * , idt identifierList1 | empty
	 */
	public void identifierList1(ProcedureRecord record,Offset offset,Type type,int count,Total total) {
		Token commaToken = new Token(TokenType.SYMBOL, ",");
		VariableRecord variableRecord = null;
		ParamNode param = null;
		if (curToken.equals(commaToken)) {
			match(commaToken);
			matchType(TokenType.ID);
			symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
			symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth
			
			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			if(tableEntry != null){
				variableRecord = new VariableRecord ();
			//	variableRecord.setOffset(offset);
				tableEntry.setRecord(variableRecord);

				//set vartype,size,offset
			
				if(record != null){
					record.setNoOfParameters(record.getNoOfParameters() +1);
					//record.setSizeOfLocalVariables(record.getSizeOfLocalVariables() + variableRecord.getSize());
					 param = new ParamNode();
					//param.setParameterType(variableRecord.getVarType());
					ParamNode node = null;
					node = record.getParameterList();
					if(node == null)
					{
						record.setParameterList(param);
					}
					else
					{
					    while(node.getNext() != null) {
					    	node = node.getNext();
					    }
						node.setNext(param);
					}
				}
				
			}
			curToken = lexical.getNextToken();
			
			count++;
			total.setNo(total.getNo() + 1);
			identifierList1(record,offset,type,count,total);
			
		}
		
		else {
		Token colonToken = new Token(TokenType.SYMBOL, ":");
		match(colonToken);
	
		typeMark(type);
		}
		
		if(variableRecord != null ){
		setSizeOffsetType(record,variableRecord,type, param);
		variableRecord.setOffset(offset.getOffset() + count*type.getOffset());
		if(param != null) {
			param.setOffset(variableRecord.getOffset());
		    }
	//	offset.setOffset(offset.getOffset() + count*type.getOffset() );
		}
	}

	/**
	 * Method to evaluate the rule for VarTail Rule : VarTail -> IdentifierList
	 * : TypeMark ; VarTail | empty
	 */
	public void varTail(Offset offset) {

		if (curToken.getType() == TokenType.ID) {

			identifierList(null,offset);
			
			/*
			Token colonToken = new Token(TokenType.SYMBOL, ":");
			match(colonToken);
			Type type = new Type();
			typeMark(type);
			*/
			Token semicolonToken = new Token(TokenType.SYMBOL, ";");
			match(semicolonToken);
			varTail(offset);
		}
	}

	/**
	 * Method to evaluate the rule for VarPart Rule : VarPart -> vart VarTail |
	 * empty
	 */
	public void varPart(Offset offset) {

		Token varToken = new Token(TokenType.RESWORD, "VAR");
		if (curToken.equals(varToken)) {
			match(varToken);
			varTail(offset);
		}
	}

	/**
	 * Method to evaluate the rule for ConstTail Rule : ConstTail -> idt = Value
	 * ; ConstTail | empty
	 */
	public void constTail(Offset offset) {

		if (curToken.getType() == TokenType.ID) {
			matchType(TokenType.ID);
			symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
			symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth()); //make the change in the depth
			
			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			
			curToken = lexical.getNextToken();
			Token equalToken = new Token(TokenType.RELOP, "=");
			match(equalToken);
			
			value();
			
			if(tableEntry != null){
				ConstantRecord  constantRecord;
				constantRecord = new ConstantRecord();
				tableEntry.setRecord(constantRecord);
				if(curToken.getValue().contains(".")) {
					constantRecord.setfValue(Float.parseFloat(curToken.getValue()));
					constantRecord.setVarType(VarType.realType);
					constantRecord.setOffset(offset.getOffset());
					offset.setOffset(offset.getOffset() + 4);
					//set the offset
				}
				else {
					constantRecord.setiValue(Integer.parseInt(curToken.getValue()));
					constantRecord.setVarType(VarType.intType);
					constantRecord.setOffset(offset.getOffset());
					offset.setOffset(offset.getOffset() + 2);
					//set the offset
				}
				
			}
			curToken = lexical.getNextToken();
			
			Token semicolonToken = new Token(TokenType.SYMBOL, ";");
			match(semicolonToken);
			constTail(offset);
		}

	}

	/**
	 * Method to evaluate the rule for ConstPart Rule : ConstPart -> constt
	 * ConstTail | empty
	 */
	public void constPart(Offset offset) {
		Token constToken = new Token(TokenType.RESWORD, "CONST");
		if (curToken.equals(constToken)) {
			match(constToken);
			
			constTail(offset);
		}

	}

	/**
	 * Method to evaluate the rule for DeclarativePart Rule : DeclarativePart ->
	 * ConstPart VarPart ProcPart
	 */
	public void declarativePart(Offset offset) {
		constPart(offset);
		
		varPart(offset);
		procPart();

	}

	//
	/**
	 * Method to evaluate the rule for Prog Rule : Prog -> modulet idt;
	 * DeclarativePart StatementPart endt idt.
	 */
	public void prog() {
		Token moduleToken = new Token(TokenType.RESWORD, "MODULE");

		match(moduleToken);
		matchType(TokenType.ID);
       // System.out.println("the current token" +curToken.getLexeme());
		symbolTable.checkForDups(curToken.getLexeme(), symbolTable.getDepth(),curToken.getLinenum());
		symbolTable.insert(curToken.getLexeme(), curToken.getType(),symbolTable.getDepth());
		
		curToken = lexical.getNextToken();
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		match(semicolonToken);
		symbolTable.setDepth(symbolTable.getDepth() + 1);
		//int offset = 0;
		Offset offset = new Offset();
		declarativePart(offset);
		statementPart();
		symbolTable.writeTable(symbolTable.getDepth());
		symbolTable.deleteDepth(symbolTable.getDepth());
		Token endToken = new Token(TokenType.RESWORD, "END");
		match(endToken);
		symbolTable.setDepth(symbolTable.getDepth() - 1);
		symbolTable.writeTable(symbolTable.getDepth());
		symbolTable.deleteDepth(symbolTable.getDepth());
		matchType(TokenType.ID);
		curToken = lexical.getNextToken();
		Token periodToken = new Token(TokenType.SYMBOL, ".");
		match(periodToken);
	}

	/**
	 * 
	 * @param message
	 */
	public void error(String message) {
		throw new RuntimeException(message + " - " + curToken);
	}
	/**
	 * Method to evaluate the rule for seqOfStatements Rule : seqOfStatements -> Statement  ; StatTail |empty
	 */
	
	public void seqOfStatements()
	{
		if (curToken.getType() == TokenType.ID) 
		{
			Statement();
			Token semicolon = new Token(TokenType.SYMBOL, ";");
			match(semicolon);
			StatTail();
		}	
	}
	
	/**
	 * Method to evaluate the rule for StatTail Rule : StatTail -> Statement  ; StatTail |Empty
	 */
public void StatTail()
	{
	if (curToken.getType() == TokenType.ID) 
	{
		Statement();
		Token semicolon = new Token(TokenType.SYMBOL, ";");
		match(semicolon);
		StatTail();
	}
	
	}
/**
 * Method to evaluate the rule for Statement Rule : Statement -> AssignStat	|IOStat
 */
public void Statement()
{
	if (curToken.getType() == TokenType.ID) 
	{
		AssignStat();	
	}
	else 
		IOStat();
}
/**
 * Method to evaluate the rule for AssignStat Rule : AssignStat -> idt  :=  Expr
 */

	public void AssignStat()
	{
		TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
		if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
			error("Undeclared variable at line :"+curToken.getLinenum());
		}
	
		matchType(TokenType.ID);
		curToken = lexical.getNextToken();
		Token assigment = new Token(TokenType.ASSIGNOP, ":=");
			match(assigment);
			Expr();
	}
	/**
	 * Method to evaluate the rule for IOStat Rule : IOStat -> empty
	 */
	public void IOStat()
	{
		
	}
	/**
	 * Method to evaluate the rule for Expr Rule : Expr -> Relation
	 */
	public void  Expr(){
		
		Relation();
	}
	/**
	 * Method to evaluate the rule for Relation Rule : Relation -> SimpleExpr
	 */
	public void Relation()
	{
		SimpleExpr();
	}
	/**
	 * Method to evaluate the rule for SimpleExpr Rule : SimpleExpr -> Term MoreTerm
	 */
	public void SimpleExpr()
	{
		Term();
		MoreTerm();	
	}
	
	/**
	 * Method to evaluate the rule for MoreTerm Rule : MoreTerm -> Addop Term MoreTerm| empty
	 */
	public void MoreTerm()
	{
		
		Token addOp = new Token(TokenType.ADDOP, "+");
		Token subOp = new Token(TokenType.ADDOP, "-");
		Token orOp = new Token(TokenType.ADDOP, "OR");
		if ( curToken.equals(addOp) ||curToken.equals(subOp) ||curToken.equals(orOp))
		{
			addOp();
			Term();
			MoreTerm();
		}
	}

	
	/**
	 * Method to evaluate the rule for Term Rule : Term -> Factor  MoreFactor
	 */
	public void Term()
	{
		factor();
		MoreFactor();
	}
	/**
	 * Method to evaluate the rule for MoreFactor Rule : MoreFactor -> Mulop Factor MoreFactor| empty
	 */
	public void MoreFactor(){
		Token diviop = new Token(TokenType.MULOP, "/");
		Token divop = new Token(TokenType.MULOP, "DIV");
		Token modop = new Token(TokenType.MULOP, "MOD");
		Token assigop = new Token(TokenType.MULOP, "AND");
		Token mulop = new Token(TokenType.MULOP, "*");
		 
		if ( curToken.equals(mulop) ||curToken.equals(diviop) ||curToken.equals(divop) ||curToken.equals(modop) ||curToken.equals(assigop)) {
			Mulop();
			factor();
			MoreFactor();
			
		}
	}
	
	/**
	 * Method to evaluate the rule for factor Rule : factor -> idt |numt| ( Expr )|~ Factor|SignOp Factor
	 * empty
	 */
public void factor(){
		Token openParToken = new Token(TokenType.SYMBOL, "(");
		Token negation = new Token(TokenType.SYMBOL, "~");
		Token closeParToken = new Token(TokenType.SYMBOL, ")");
		
		if (curToken.getType() == TokenType.ID) {
			
			TableEntry tableEntry = symbolTable.lookup(curToken.getLexeme());
			if(tableEntry == null || tableEntry.getDepth() > symbolTable.getDepth() ) {
				error("Undeclared variable at line :"+curToken.getLinenum());
			}
			
			matchType(TokenType.ID);	
			curToken = lexical.getNextToken();
		}
		else if(curToken.getType() == TokenType.NUMBER) 
		{
		matchType(TokenType.NUMBER);
		curToken = lexical.getNextToken();
		}
		else if(curToken.equals(openParToken))
		{
			match(openParToken);
			Expr();
			match(closeParToken);
		}
		else if(curToken.equals(negation))
		{
			match(negation);
			factor();
		}
		else
		{
			SignOp();
			factor();
		}
			
	}
	
	
/**
 * Method to evaluate the rule for addOp Rule : addOp ->Addop		+ | - | OR
 */
	public void addOp()
	{
		Token addOp = new Token(TokenType.ADDOP, "+");
		Token subOp = new Token(TokenType.ADDOP, "-");
		Token orOp = new Token(TokenType.ADDOP, "OR");
		if (curToken.equals(addOp)) {
			match(addOp);
			}
		else if (curToken.equals(subOp)) {
			match(subOp);
			}
		else  {
			match(orOp);
			}
	}
	
	/**
	 * Method to evaluate the rule for Mulop Rule : Mulop ->  *| /  |DIV|MOD| AND
	 */
	public void Mulop(){
		Token diviop = new Token(TokenType.MULOP, "/");
		Token divop = new Token(TokenType.MULOP, "DIV");
		Token modop = new Token(TokenType.MULOP, "MOD");
		Token assigop = new Token(TokenType.MULOP, "AND");
		Token mulop = new Token(TokenType.MULOP, "*");
		if (curToken.equals(mulop)) {
		match(mulop);
		}
		else if (curToken.equals(diviop)) 
			{
			match(diviop);
		}
		else if (curToken.equals(divop)) 
		{
		match(divop);
	}
		else if (curToken.equals(modop)) 
		{
		match(modop);
	}
		else
		match(assigop);
	
			
	}
	/**
	 * Method to evaluate the rule for SignOp Rule : SignOp -> -
	 */
	public void SignOp(){
		
		Token signop = new Token(TokenType.ADDOP, "-");
		match(signop);
		
	}
	
	 
	
	
}

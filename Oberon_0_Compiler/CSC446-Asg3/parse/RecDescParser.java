package parse;

import java.io.Reader;

import analyzer.Lexical;
import analyzer.Token;
import analyzer.TokenType;

/**
 * 
 * @author Nisha Patel Date : 02/14/2013
 * 
 *         This class implements the Recursive Descent Parser. It evaluates the
 *         given grammar to parse the tokens generated by the Lexical Analyzer.
 * 
 */
public class RecDescParser {

	/**
	 * This is the current token to be evaluated.
	 */
	private Token curToken;

	/**
	 * The reference for the Lexical Analayzer.
	 */
	private Lexical lexical = null;

	/**
	 * The constructor for the Parser.
	 * 
	 * @param reader
	 */
	public RecDescParser(Reader reader) {
		lexical = new Lexical(reader);
	}

	/**
	 * Returns the Next token from the Lexical Analyzer.
	 */
	public void getNextToken() {
		curToken = lexical.getNextToken();
	}

	/**
	 * Returns the Current Token.
	 * 
	 * @return The current token to be analyzed
	 */
	public Token getCurToken() {
		return curToken;
	}

	/**
	 * Matches the given token with the {@code curToken}
	 * 
	 * @param symbol
	 *            The token to be matched with the {@code curToken}
	 */
	private void match(Token symbol) {
		if (curToken.equals(symbol))
			curToken = lexical.getNextToken();
		else
			error("Error token mismatch");
	}

	/**
	 * Matches the given token type with the type of the {@code curToken}
	 * 
	 * @param tokenType
	 *            The token type to be matched with the type of the
	 *            {@code curToken}
	 */
	private void matchType(TokenType tokenType) {
		if (curToken.getType() == tokenType)
			curToken = lexical.getNextToken();
		else
			error("Error token Type mismatch");
	}

	/**
	 * Method to evaluate the rule for SeqOfStatements Rule : SeqOfStatements ->
	 * empty
	 */
	public void seqOfStatements() {

	}

	/**
	 * Method to evaluate the rule for StatementPart Rule : StatementPart ->
	 * begint SeqOfStatements | empty
	 */
	public void statementPart() {
		Token beginToken = new Token(TokenType.RESWORD, "BEGIN");
		if (curToken.equals(beginToken)) {
			match(beginToken);
			seqOfStatements();
		}
	}

	/**
	 * Method to evaluate the rule for Mode Rule : Mode -> vart | empty 
	 */
	public void mode() {

		Token varToken = new Token(TokenType.RESWORD, "VAR");
		if (curToken.equals(varToken)) {
			match(varToken);

		}
	}

	/**
	 * Method to evaluate the rule for MoreArgs Rule : MoreArgs -> ; ArgList | empty
	 */
	public void moreArgs() {
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		if (curToken.equals(semicolonToken)) {
			match(semicolonToken);
			argList();

		}
	}

	/**
	 * Method to evaluate the rule for ArgList Rule : ArgList -> Mode
	 * IdentifierList : TypeMark MoreArgs
	 */
	public void argList() {
		mode();
		identifierList();
		Token colonToken = new Token(TokenType.SYMBOL, ":");
		match(colonToken);
		typeMark();
		moreArgs();

	}

	/**
	 * Method to evaluate the rule for Args Rule : Args -> ( ArgList ) | empty
	 */
	public void args() {
		Token openParToken = new Token(TokenType.SYMBOL, "(");
		if (curToken.equals(openParToken)) {
			match(openParToken);
			argList();
			Token closeParToken = new Token(TokenType.SYMBOL, ")");
			match(closeParToken);
		}

	}

	/**
	 * Method to evaluate the rule for ProcBody Rule : ProcBody ->
	 * DeclarativePart StatementPart endt
	 */
	public void procBody() {
		declarativePart();
		statementPart();
		Token endToken = new Token(TokenType.RESWORD, "END");
		match(endToken);
	}

	/**
	 * Method to evaluate the rule for ProcHeading Rule : ProcHeading -> proct
	 * idt Args
	 */
	public void procHeading() {
		Token procToken = new Token(TokenType.RESWORD, "PROCEDURE");
		match(procToken);
		matchType(TokenType.ID);
		args();
	}

	/**
	 * Method to evaluate the rule for ProcedureDecl Rule : ProcedureDecl ->
	 * ProcHeading ; ProcBody idt ;
	 */
	public void procedureDecl() {

		procHeading();
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		match(semicolonToken);
		procBody();
		matchType(TokenType.ID);
		match(semicolonToken);

	}

	/**
	 * Method to evaluate the rule for ProcPart Rule : ProcPart -> ProcedureDecl
	 * ProcPart | empty
	 */
	public void procPart() { // This call methode call self We need to make
								// change to LL1
		Token procToken = new Token(TokenType.RESWORD, "PROCEDURE");
		if (curToken.equals(procToken)) {
			procedureDecl();
			procPart();
		}
	}

	/**
	 * Method to evaluate the rule for Value Rule : Value -> NumericalLiteral
	 */
	public void value() {
		matchType(TokenType.NUMBER);
		
		}

	/**
	 * Method to evaluate the rule for TypeMark Rule : TypeMark -> integert |
	 * realt | chart
	 */
	public void typeMark() {
		Token integerToken = new Token(TokenType.RESWORD, "INTEGER");
		Token realToken = new Token(TokenType.RESWORD, "REAL");
		Token charToken = new Token(TokenType.RESWORD, "CHAR");
		if (curToken.equals(integerToken)) {
			match(integerToken);
		}

		else if (curToken.equals(realToken)) {
			match(realToken);
		} else if (curToken.equals(charToken)) {
			match(charToken);
		}

		else
			error("Error: No match found for integert | realt | chart in typemark ");
	}

	/**
	 * Method to evaluate the rule for IdentifierList Rule : IdentifierList ->
	 * idt identifierList1
	 */
	public void identifierList() { // convert this gramarer to LL1 grammare

		matchType(TokenType.ID);
		identifierList1();
	}

	/**
	 * Method to evaluate the rule for IdentifierList1 Rule : IdentifierList1 ->
	 * , idt identifierList1 | empty
	 */
	public void identifierList1() {
		Token commaToken = new Token(TokenType.SYMBOL, ",");
		if (curToken.equals(commaToken)) {
			match(commaToken);
			matchType(TokenType.ID);
			identifierList1();
		}
	}

	/**
	 * Method to evaluate the rule for VarTail Rule : VarTail -> IdentifierList
	 * : TypeMark ; VarTail | empty
	 */
	public void varTail() {

		if (curToken.getType() == TokenType.ID) {

			identifierList();
			Token colonToken = new Token(TokenType.SYMBOL, ":");
			match(colonToken);
			typeMark();
			Token semicolonToken = new Token(TokenType.SYMBOL, ";");
			match(semicolonToken);
			varTail();
		}
	}

	/**
	 * Method to evaluate the rule for VarPart Rule : VarPart -> vart VarTail |
	 * empty
	 */
	public void varPart() {

		Token varToken = new Token(TokenType.RESWORD, "VAR");
		if (curToken.equals(varToken)) {
			match(varToken);
			varTail();
		}
	}

	/**
	 * Method to evaluate the rule for ConstTail Rule : ConstTail -> idt = Value
	 * ; ConstTail | empty
	 */
	public void constTail() {

		if (curToken.getType() == TokenType.ID) {
			matchType(TokenType.ID);
			Token equalToken = new Token(TokenType.RELOP, "=");
			match(equalToken);
			value();
			Token semicolonToken = new Token(TokenType.SYMBOL, ";");
			match(semicolonToken);
			constTail();
		}

	}

	/**
	 * Method to evaluate the rule for ConstPart Rule : ConstPart -> constt
	 * ConstTail | empty
	 */
	public void constPart() {
		Token constToken = new Token(TokenType.RESWORD, "CONST");
		if (curToken.equals(constToken)) {
			match(constToken);
			constTail();
		}

	}

	/**
	 * Method to evaluate the rule for DeclarativePart Rule : DeclarativePart ->
	 * ConstPart VarPart ProcPart
	 */
	public void declarativePart() {
		constPart();
		varPart();
		procPart();

	}

	//
	/**
	 * Method to evaluate the rule for Prog Rule : Prog -> modulet idt;
	 * DeclarativePart StatementPart endt idt.
	 */
	public void prog() {
		Token moduleToken = new Token(TokenType.RESWORD, "MODULE");

		match(moduleToken);
		matchType(TokenType.ID);
		Token semicolonToken = new Token(TokenType.SYMBOL, ";");
		match(semicolonToken);
		declarativePart();
		statementPart();
		Token endToken = new Token(TokenType.RESWORD, "END");
		match(endToken);
		matchType(TokenType.ID);
		Token periodToken = new Token(TokenType.SYMBOL, ".");
		match(periodToken);
	}

	/**
	 * 
	 * @param message
	 */
	public void error(String message) {
		throw new RuntimeException(message + " - " + curToken);
	}
}
